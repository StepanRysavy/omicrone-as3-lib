/**		Animation by oMicrone	- sdružuje základní animace	- animace jsou konfigurovatelné	- vhodné pro EBP		ChangeLog:		0.1 - ADDED: rollIn, rollAway, fadeIn, fadeOut	0.2 - ADDED: bounce, bounceAndRoll	*/package com.omicrone {		import flash.display.MovieClip;	import flash.events.Event;
		public class Animation {				private static var settings:Object = {};				public static function get (s:String):* {			if (settings[s] != undefined) {				return settings[s];			} else {				return null;			}		}				public static function set (s:String, o:*):void {			//trace ("  ~ nastavuji", s, "na hodnotu", o);			settings[s] = o;		}				/**		 * 		 * Vytvoří sekvenci volání funkcí		 * 		 * @param timeline (Array of Object) je pole objektů vzniklých funkcí createAnimation		 * @param mc (*) je pomocný animační objekt, který se stará o samotný běh		 * 		 */		public static function animate (timeline:Array, mc:* = null):void {			trace ("  ~ nastavuji animační sekvenci");						if (mc == null) mc = new MovieClip();						mc.timer = 0;			mc.timerMax = 0;						var i:uint;			var aniInfo:Object;						for (i = 0; i < timeline.length; i++) {				aniInfo = timeline[i];				if (aniInfo.timer > mc.timerMax) mc.timerMax = aniInfo.timer;				aniInfo.mc.addEventListener ("animationStepper_" + aniInfo.timer, aniInfo.fce);			}						trace ("  ~ spouštím animaci");			mc.addEventListener (Event.ENTER_FRAME, stepper); 									function stepper (e:Event):void {								if (mc.timer > mc.timerMax) {					mc.removeEventListener (Event.ENTER_FRAME, stepper); 										for (i = 0; i < timeline.length; i++) {						aniInfo = timeline[i];						aniInfo.mc.removeEventListener ("animationStepper_" + aniInfo.timer, aniInfo.fce);					}										trace ("  ~ ukončuji animaci");				} else {					for (i = 0; i < timeline.length; i++) {						aniInfo = timeline[i];						aniInfo.mc.dispatchEvent (new Event ("animationStepper_"+mc.timer));					}					mc.timer++;				}			}		}				/**		 * Vytvoří animační objekt		 * 		 * @param time (uint) je čas inicializace v průběhu skriptu		 * @param mc (*) identifikuje animovaný objekt		 * @param fce (Function) identifikuje prováděnou akci		 * 		 */		public static function createAnimation (time:uint, mc:*, fce:Function):Object {						trace ("  ~ vytvářím objekt pro animaci", mc.name, time);						var aniInfo:Object = {};			aniInfo.mc = mc;			aniInfo.timer = time;			aniInfo.fce = fce;						return aniInfo;		}				/**			Příjezd postupným zrychlením s eventem po dokončení			 * 			 * @param mc (*) je animovaný objekt			 * @param fce (Function) je funkce volaná po dokončení animace			 * @param event (String) je událost volaná po dokončení animace			 * @param eventMC (*) je objekt, na kterém se má volat událost			 * @param distanceX (Number) je počáteční vzdálenost X			 * @param distanceY (Number) je počáteční vzdálenost Y			 * @param speed (Number) je konstanta do vzorce pro rychlost		*/		public static function bounce (mc:*, fce:Function = null, event:String = null, eventMC:* = null, distanceX:Number = 50, distanceY:Number = 0, speed:Number = 100):void {						var positionX:Number = mc.x;			var positionY:Number = mc.y;						trace ("  ~", "bounce() pro objekt", mc.name);						mc.x += distanceX;			mc.y += distanceY;						mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("bounceStepper", fce);			function stepper (e:Event):void {				if (mc.x == positionX && mc.y == positionY) {					mc.removeEventListener (Event.ENTER_FRAME, stepper);					if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("rollInStepper")); 					if (fce != null) mc.removeEventListener ("rollInStepper", fce);				}				if (mc.x != positionX) {					if (mc.x < positionX) {						mc.x += speed / ((positionX - mc.x));						if (positionX - mc.x < 1) mc.x = positionX;					} else {						mc.x -= speed / ((mc.x - positionX));						if (mc.x - positionX < 1) mc.x = positionX;					}				}				if (mc.y != positionY) {					if (mc.y < positionY) {						mc.y += speed / ((positionY - mc.y));						if (positionY - mc.y < 1) mc.y = positionY;					} else {						mc.y -= speed / ((mc.y - positionY));						if (mc.y - positionY < 1) mc.y = positionY;					}				}			}		}				/**			Příjezd postupným zrychlením s deceleračním odrazem a eventem po dokončení			 * @param mc (*) je animovaný objekt			 * @param fce (Function) je funkce volaná po dokončení animace			 * @param event (String) je událost volaná po dokončení animace			 * @param eventMC (*) je objekt, na kterém se má volat událost			 * @param distanceX (Number) je počáteční vzdálenost X			 * @param distanceY (Number) je počáteční vzdálenost Y			 * @param speed (Number) je konstanta do vzorce pro rychlost		*/		public static function bounceAndRoll (mc:*, fce:Function = null, event:String = null, eventMC:* = null, distanceX:Number = 50, distanceY:Number = 0, speed:Number = 100):void {						var positions:Object = {x:mc.x, y:mc.y}			var positionX:Number = Math.round(mc.x - (distanceX / 10));			var positionY:Number = Math.round(mc.y - (distanceY / 10));						trace ("  ~", "bounceAndRoll() pro objekt", mc.name);						mc.x += distanceX;			mc.y += distanceY;						mc.addEventListener (Event.ENTER_FRAME, stepper);			function stepper (e:Event):void {				if (mc.x == positionX && mc.y == positionY) {					mc.removeEventListener (Event.ENTER_FRAME, stepper);					mc.x = positions.x;					mc.y = positions.y;					//Animation.move (mc, mc.x - positionX, mc.y - positionY, 3, true, true, fce, event, eventMC);				}				if (mc.x != positionX) {					if (mc.x < positionX) {						mc.x += speed / ((positionX - mc.x));						if (positionX - mc.x < 1) mc.x = positionX;					} else {						mc.x -= speed / ((mc.x - positionX));						if (mc.x - positionX < 1) mc.x = positionX;					}				}				if (mc.y != positionY) {					if (mc.y < positionY) {						mc.y += speed / ((positionY - mc.y));						if (positionY - mc.y < 1) mc.y = positionY;					} else {						mc.y -= speed / ((mc.y - positionY));						if (mc.y - positionY < 1) mc.y = positionY;					}				}			}		}				/**		 * 		 * Posun na souřadnice x,y		 * 		 * @param mc (*) je animovaný objekt		 * @param toX (Number) specifikuje cílovou x souřadnici		 * @param toY (Number) specifikuje cílovou y souřadnici		 * @param speed (Number) specifikuje rychlost		 * @param momentum (Boolean) specifikuje, zda se jedná o lineární nebo nelineární posun		 * @param decelerate (Boolean) specifikuje, zda je momentum zpomalující nebo zrychlující		 * @fce (Function) je funkce volaná po přoběhnutí skriptu		 * @event (String) je událost volaná po proběhnutí skriptu		 * @eventMC (*) je objekt, nad kterým je událost volána, pokud se liší od mc		 * 		 */		public static function moveTo (mc:*, toX:Number = 0, toY:Number = 0, speed:Number = 10, momentum:Boolean = true, decelerate:Boolean = true, fce:Function = null, event:String = null, eventMC:* = null):void {						//trace ("  ~ moveTo() pro objekt", mc.name);						move (mc, toX - mc.x, toY - mc.y, speed, momentum, decelerate, fce, event, eventMC, toX, toY);		}				/**		 * Posun o vzdálenost deltaX a deltaY s možností využití momenta		 * 		 * @param mc (*) je animovaný objekt		 * @param deltaX (Number) specifikuje rozdíl x souřadnic		 * @param deltaY (Number) specifikuje rozdíl y souřadnic		 * @param speed (Number) specifikuje rychlost		 * @param momentum (Boolean) specifikuje, zda se jedná o lineární nebo nelineární posun		 * @param decelerate (Boolean) specifikuje, zda je momentum zpomalující nebo zrychlující		 * @fce (Function) je funkce volaná po přoběhnutí skriptu		 * @event (String) je událost volaná po proběhnutí skriptu		 * @eventMC (*) je objekt, nad kterým je událost volána, pokud se liší od mc		 */		public static function move (mc:*, deltaX:Number = 0, deltaY:Number = 0, speed:Number = 4, momentum:Boolean = true, decelerate:Boolean = true, fce:Function = null, event:String = null, eventMC:* = null, destX:* = null, destY:* = null):void {			if (get("move_" + mc.name) != null) {				if (get("move_" + mc.name) == true) {					trace ("  ~ ruším move() pro objekt", mc.name, "již se animuje");					return;				} 			}						//trace ("  ~ move() pro objekt", mc.name);						if (get("move_" + mc.name) != null) {				if (get("move_" + mc.name) == false) {					if (!mc.hasEventListener ("moveStepper")) mc.addEventListener ("moveStepper", reset);					if (fce != null) mc.addEventListener ("moveStepper", fce);										set("move_" + mc.name, true);				}			} else {				if (!mc.hasEventListener ("moveStepper")) mc.addEventListener ("moveStepper", reset);				if (fce != null) mc.addEventListener ("moveStepper", fce);								set("move_" + mc.name, true);			}						mc.addEventListener (Event.ENTER_FRAME, stepper);						var div:Number;			var originX:Number = deltaX;			var originY:Number = deltaY;						function stepper (e:Event):void {				if (deltaX == 0 && deltaY == 0) {					mc.dispatchEvent (new Event ("moveStepper"));				} else {					if (momentum) {						if (deltaX != 0) {							if (deltaX > 0) {								if (deltaX < .5) {									mc.x += deltaX;									deltaX = 0;								} else {									if (decelerate) {										div = deltaX / speed;										} else {										div = 1 +( originX - deltaX) / speed;									}									mc.x += div;									deltaX -= div;									if (deltaX < 0) {										mc.x -= deltaX;										deltaX = 0;									}								}							} else {								if (deltaX > -.5) {									mc.x += deltaX;									deltaX = 0;								} else {									if (decelerate) {										div = deltaX / speed;										} else {										div = (originX - deltaX) / speed - 1;									}									mc.x += div;									deltaX -= div;									if (deltaX > 0) {										mc.x += deltaX;										deltaX = 0;									}								}							}						}						if (deltaY != 0) {							if (deltaY > 0) {								if (deltaY < .5) {									mc.y += deltaY;									deltaY = 0;								} else {									if (decelerate) {										div = deltaY / speed;										} else {										div = 1 +( originY - deltaY) / speed;									}									mc.y += div;									deltaY -= div;									if (deltaY < 0) {										mc.y -= deltaY;										deltaY = 0;									}								}							} else {								if (deltaY > -.5) {									mc.y += deltaY;									deltaY = 0;								} else {									if (decelerate) {										div = deltaY / speed;										} else {										div = ( originY - deltaY) / speed - 1;									}									mc.y += div;									deltaY -= div;									if (deltaY > 0) {										mc.y += deltaY;										deltaY = 0;									}								}							}						}					} else {						if (deltaX != 0) {							if (deltaX > 0) {								mc.x += speed;								deltaX -= speed;								if (deltaX < 0) {									mc.x += deltaX;									deltaX = 0;								}							} else {								mc.x -= speed;								deltaX += speed;								if (deltaX > 0) {									mc.x -= deltaX;									deltaX = 0;								}							}						}						if (deltaY != 0) {							if (deltaY > 0) {								mc.y += speed;								deltaY -= speed;								if (deltaY < 0) {									mc.y += deltaY;									deltaY = 0;								}							} else {								mc.y -= speed;								deltaY += speed;								if (deltaY > 0) {									mc.y -= deltaY;									deltaY = 0;								}							}						}					}				}			}						function reset (e:Event):void {								//trace ("  ~ move() reset");								set("move_" + mc.name, false);				if (eventMC != null && event != null) eventMC.dispatchEvent (new Event (event));				if (fce != null) mc.removeEventListener ("moveStepper", fce);				mc.removeEventListener ("moveStepper", reset);			}					}		/**		 * Prolnutí do hodnoty fadeTo		 * 		 * @param mc (*) je animovaný objekt		 * @param fadeTo (Number) je finální požadovaná hodnota alpha		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param momentum (Boolean) určuje, zda je pohyb lineární nebo hyperbolický		 */		public static function fade (mc:*, fadeTo:Number, fce:Function = null, event:String = null, eventMC:* = null, speed:Number = 0.1, momentum:Boolean = false):void {						trace ("  ~ fade() pro objekt", mc.name);						if (fadeTo > mc.alpha) {				fadeIn (mc, fce, event, eventMC, speed, momentum, fadeTo);			} else {				fadeOut (mc, fce, event, eventMC, speed, momentum, fadeTo);			}		}				/**			Prolnutí s eventem		 * 		 * @param mc (*) je animovaný objekt		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param momentum (Boolean) určuje, zda je pohyb lineární nebo hyperbolický		 * @param fadeInTo (Number) je finální požadovaná hodnota alpha		*/		public static function fadeIn (mc:*, fce:Function = null, event:String = null, eventMC:* = null, speed:Number = 0.1, momentum:Boolean = false, fadeInTo:Number = 1):void {						trace ("  ~", "fadeIn() pro objekt", mc.name);						mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("fadeInStepper", fce);			function stepper (e:Event):void {				if (mc.alpha < fadeInTo) {					if (momentum) {						mc.alpha += (fadeInTo - mc.alpha) / speed;						if (mc.alpha > fadeInTo - .01) mc.alpha = fadeInTo;					} else {						mc.alpha += speed;					}				} else {					mc.alpha = fadeInTo;					mc.removeEventListener (Event.ENTER_FRAME, stepper);					if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("fadeInStepper")); 					if (fce != null) mc.removeEventListener ("fadeInStepper", fce);				}			}		}				/**			Zmizení		 * 		 * @param mc (*) je animovaný objekt		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param momentum (Boolean) určuje, zda je pohyb lineární nebo hyperbolický		 * @param fadeOutTo (Number) je finální požadovaná hodnota alpha		*/		public static function fadeOut (mc:*, fce:Function = null, event:String = null, eventMC:* = null, speed:Number = 0.05, momentum:Boolean = false, fadeOutTo:Number = 0):void {						trace ("  ~", "fadeOut() pro objekt", mc.name);			mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("fadeOutStepper", fce);			function stepper (e:Event):void {				if (mc.alpha > fadeOutTo) {					if (momentum) {						mc.alpha -= (mc.alpha - fadeOutTo) / speed;						if (mc.alpha < fadeOutTo + 0.01) mc.alpha = fadeOutTo;					} else {						mc.alpha -= speed;					}				} else {					mc.alpha = fadeOutTo;					mc.removeEventListener (Event.ENTER_FRAME, stepper);					if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("fadeOutStepper")); 					if (fce != null) mc.removeEventListener ("fadeOutStepper", fce);				}			}		}				/**		 * 		 * Zavrtění		 * 		 * @param mc (*) je animovaný objekt		 * @param times (uint) počet cyklů zavrtění		 * @param amount (Number) počet stupňů naklonění		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param momentum (Boolean) určuje, zda je pohyb lineární nebo hyperbolický		 * 		 */		public static function wiggle (mc:*, times:uint = 3, amount:Number = 1, speed:Number = 1, wiggleSpeed:Number = 1, wiggleMomentum:Boolean = false, fce:Function = null, event:String = null, eventMC:* = null, momentum:Boolean = true):void {			if (get("wiggle_" + mc.name) != null) {				if (get("wiggle_" + mc.name) == true) {					trace ("  ~ ruším wiggle() pro objekt", mc.name, "již se animuje");					return;				} 			}						trace ("  ~ wiggle() pro objekt", mc.name);							var currentLoop:uint = 0;			var originalRotation:Number = mc.rotation;			if (times < 1) times = 1;									function turnFirst():void {								if (fce != null) mc.addEventListener ("wiggleStepper", fce);								mc.addEventListener ("wiggleLeft", turnLeft);				mc.addEventListener ("wiggleRight", turnRight);								mc.dispatchEvent (new Event ("wiggleLeft"));			}						function turnLeft(e:Event):void {								if (currentLoop == 0) {					rotate (mc, amount, amount / 2, turnRight, null, null, false);				} else if (currentLoop == times) {					rotate (mc, amount, speed, null, "wiggleStepper", mc, true);				} else {					rotate (mc, amount*2, wiggleSpeed, turnRight, null, null, wiggleMomentum);				}								if (momentum && amount > .1) amount *= .9;				if (wiggleMomentum) wiggleSpeed *= 2;							}						function turnRight(e:Event):void {								rotate (mc, -amount*2, -wiggleSpeed, turnLeft, null, null, wiggleMomentum);								if (momentum && amount > .1) amount *= .9;				if (wiggleMomentum) wiggleSpeed *= 2;				currentLoop++;			}						if (get("wiggle_" + mc.name) != null) {				if (get("wiggle_" + mc.name) == false) {					if (!mc.hasEventListener ("wiggleStepper")) mc.addEventListener ("wiggleStepper", reset);										set("wiggle_" + mc.name, true);					turnFirst ();				}			} else {				if (!mc.hasEventListener ("wiggleStepper")) mc.addEventListener ("wiggleStepper", reset);								set("wiggle_" + mc.name, true);				turnFirst ();			}						function reset (e:Event):void {								set("wiggle_" + mc.name, false);				if (eventMC != null && event != null) eventMC.dispatchEvent (new Event (event));				if (fce != null) mc.removeEventListener ("wiggleStepper", fce);				mc.removeEventListener ("wiggleStepper", reset);				mc.removeEventListener ("wiggleLeft", turnLeft);				mc.removeEventListener ("wiggleRight", turnRight);				mc.rotation = originalRotation;			}		}				/**		 * 		 * Rotace		 * 		 * @param mc (*) je animovaný objekt		 * @param amount (Number) počet stupňů naklonění		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param momentum (Boolean) určuje, zda je pohyb lineární nebo hyperbolický		 * 		 */		public static function rotate (mc:*, amount:Number = 45, speed:Number = 10, fce:Function = null, event:String = null, eventMC:* = null, momentum:Boolean = true):void {			trace ("  ~ rotace() pro objekt", mc.name);						if (momentum) {				if (speed < 0) speed *= -1;			} else {				if (amount < 0 && speed > 0) speed *= -1;				if (amount > 0 && speed < 0) speed *= -1;			}						mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("rotateStepper", fce);						var more:Number;						if (amount > 180) {				more = amount - 180;				amount = -180 + more;			}			if (amount < -180) {				more = amount + 180;				amount = 180 - more;			}						var originalAngle:Number = mc.rotation;			var originalAmount:Number = amount;			var dif:Number = amount;						function stepper (e:Event):void {								if (amount == 0) {										mc.rotation = originalAngle + originalAmount;					mc.removeEventListener (Event.ENTER_FRAME, stepper);										if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("rotateStepper")); 					if (fce != null) mc.removeEventListener ("rotateStepper", fce);									} else {										if (momentum) {						dif = amount / speed;						mc.rotation += dif;						amount -= dif;					} else {						dif = amount - speed;						mc.rotation += speed;						amount -= speed;					}										if (momentum) {						if (amount < .2 && amount > -.2) amount = 0;					} else {						if (amount < 0 && speed > 0) amount = 0;						if (amount > 0 && speed < 0) amount = 0;					}									}			}		}				/**		 * 		 * Bumpnutí, zvětší objekt a pak ho opět zmenší		 * 		 * @param mc (*) je animovaný objekt		 * @param toScale (uint) maximální hodnota		 * @param speedLarger (Number) rychlost zvětšení (čím menší, tím rychlejší)		 * @param speedSmaller (Number) rychlost zmenšení (čím menší, tím rychlejší)		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * 		 */		public static  function bump (mc:*, toScale:Number = 10, fce:Function = null, event:String = null, eventMC:* = null, speedLarger:Number = 1.5, speedSmaller:Number = 4):void {			trace ("  ~ bump() pro objekt", mc.name);						var originalX:Number = mc.scaleX;			var originalY:Number = mc.scaleY;						function part1 ():void {				rescale (mc, originalX / (1 - toScale/100), originalY / (1 - toScale/100), speedLarger, part2, null, null);			}						function part2 (e:Event):void {				rescale (mc, originalX, originalY, speedSmaller, null, "bumpStepper", mc);			}						if (get("bump_"+mc.name) != null) {				if (get("bump_"+mc.name) == false) {					if (!mc.hasEventListener("bumpStepper")) mc.addEventListener ("bumpStepper", reset);					if (fce != null) mc.addEventListener ("bumpStepper", fce);										part1 ();					set("bump_"+mc.name, true);				}			} else {				if (!mc.hasEventListener("bumpStepper")) mc.addEventListener ("bumpStepper", reset);				if (fce != null) mc.addEventListener ("bumpStepper", fce);								part1 ();				set("bump_"+mc.name, true);			}							function reset (e:Event):void {				set("bump_"+mc.name, false);				if (fce != null) mc.removeEventListener ("bumpStepper", fce);			}					}				/**		 * 		 * Uskočení		 * 		 * @param mc (*) je animovaný objekt		 * @param toScale (Number) o jakou hodnotu se zmenší		 * @param speedLarger (Number) rychlost zvětšení (čím menší, tím rychlejší)		 * @param speedSmaller (Number) rychlost zmenšení (čím menší, tím rychlejší)		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * 		 */		public static  function duck (mc:*, toScale:Number = 10, fce:Function = null, event:String = null, eventMC:* = null, speedLarger:Number = 4, speedSmaller:Number = 1.5):void {			trace ("  ~ duck() pro objekt", mc.name);						var originalX:Number = mc.scaleX;			var originalY:Number = mc.scaleY;						function part1 ():void {				rescale (mc, originalX / (1 + toScale/100), originalY / (1 + toScale/100), speedSmaller, part2, null, null);			}						function part2 (e:Event):void {				rescale (mc, originalX, originalY, speedLarger, null, "duckStepper", mc);			}									if (get("duck_" + mc.name) != null) {				if (get("duck_" + mc.name) == false) {					if (!mc.hasEventListener("duckStepper")) mc.addEventListener ("duckStepper", reset);					if (fce != null) mc.addEventListener ("duckStepper", fce);										part1 ();					set("duck_" + mc.name, true);				}			} else {				if (!mc.hasEventListener("duckStepper")) mc.addEventListener ("duckStepper", reset);				if (fce != null) mc.addEventListener ("duckStepper", fce);								part1 ();				set("duck_" + mc.name, true);			}						function reset (e:Event):void {				set("duck_" + mc.name, false);				if (fce != null) mc.removeEventListener ("duckStepper", fce);			}					}				/**		 * 		 * Zvětšení objektu		 * 		 * @param mc (*) je animovaný objekt		 * @param toScale (Number) cílová hodnota		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param xScale (Boolean) zda se změna velikosti vztahuje na X		 * @param yScale (Boolean) zda se změna velikosti vztahuje na Y		 * 		 */		public static function makeLarger (mc:*, toScale:Number = 1.05, fce:Function = null, event:String = null, eventMC:* = null, speed:Number = 10, xScale:Boolean = true, yScale:Boolean = true):void {			//trace ("  ~ makeLarger() pro objekt", mc.name);						mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("makeLargerStepper", fce);						if (!xScale) yScale = true;						var useRatio:Boolean = false;			var scale:Number;			var ratio:Number = mc.scaleX / mc.scaleY;						if (xScale && yScale) useRatio = true;						if (!xScale) {				scale = mc.scaleY;			} else {				scale = mc.scaleX;				if (!yScale) useRatio = false;			}						function stepper (e:Event):void {				if (scale == toScale) {										mc.removeEventListener (Event.ENTER_FRAME, stepper);					if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("makeLargerStepper")); 					if (fce != null) mc.removeEventListener ("makeLargerStepper", fce);				} else {					scale += (toScale - scale) / speed;					if (scale + .001 > toScale) scale = toScale;				}								if (useRatio) {					mc.scaleX = scale;					mc.scaleY = mc.scaleX * ratio;				} else {					if (xScale) mc.scaleX = scale;					if (yScale) mc.scaleY = scale;				}			}								}				/**		 * 		 * Zmenšení objektu		 * 		 * @param mc (*) je animovaný objekt		 * @param toScale (Number) cílová hodnota		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * @param xScale (Boolean) zda se změna velikosti vztahuje na X		 * @param yScale (Boolean) zda se změna velikosti vztahuje na Y		 * 		 */		public static function makeSmaller (mc:*, toScale:* = .95, fce:Function = null, event:String = null, eventMC:* = null, speed:Number = 10, xScale:Boolean = true, yScale:Boolean = true):void {			//trace ("  ~ makeSmaller() pro objekt", mc.name);						mc.addEventListener (Event.ENTER_FRAME, stepper);			if (fce != null) mc.addEventListener ("makeSmallerStepper", fce);						if (!xScale) yScale = true;						var useRatio:Boolean = false;			var scale:Number;			var ratio:Number = mc.scaleX / mc.scaleY;						if (xScale && yScale) useRatio = true;						if (!xScale) {				scale = mc.scaleY;			} else {				scale = mc.scaleX;				if (!yScale) useRatio = false;			}						function stepper (e:Event):void {				if (scale == toScale) {										mc.removeEventListener (Event.ENTER_FRAME, stepper);					if (event != null) {						if (eventMC != null) {							eventMC.dispatchEvent (new Event (event));						} else {							mc.dispatchEvent (new Event (event));						}					}					if (fce != null) mc.dispatchEvent (new Event ("makeSmallerStepper")); 					if (fce != null) mc.removeEventListener ("makeSmallerStepper", fce);				} else {					scale -= (scale - toScale) / speed;					if (scale - .001 < toScale) scale = toScale;				}								if (useRatio) {					mc.scaleX = scale;					mc.scaleY = mc.scaleX * ratio;				} else {					if (xScale) mc.scaleX = scale;					if (yScale) mc.scaleY = scale;				}			}		}				/**		 * 		 * Změna velikosti relativne		 * 		 * @param mc (*) je animovaný objekt		 * @param toScaleX (Number) maximální hodnota		 * @param toScaleY (Number) maximální hodnota		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * 		 */		public static function rescale (mc:*, toScaleX:* = null, toScaleY:* = null, speed:Number = 10, fce:Function = null, event:String = null, eventMC:* = null):void {						if (toScaleX != null && toScaleY != null) {				//trace ("  ~ rescale(X+Y) pro objekt", mc.name);								if (toScaleX == toScaleY) {					//trace ("  ~ rescale(X&Y) pro objekt", mc.name);					if (toScaleX < mc.scaleX) {						makeSmaller (mc, toScaleX, fce, event, eventMC, speed);					} else {						makeLarger (mc, toScaleX, fce, event, eventMC, speed);					}				} else {					//trace ("  ~ rescale(X,Y) pro objekt", mc.name);					if (toScaleX < mc.scaleX) {						makeSmaller (mc, toScaleX, fce, event, eventMC, speed, true, false);					} else {						makeLarger (mc, toScaleX, fce, event, eventMC, speed, true, false);					}					if (toScaleY < mc.scaleY) {						makeSmaller (mc, toScaleY, null, null, null, speed, false);					} else {						makeLarger (mc, toScaleY, null, null, null, speed, false);					}				}			} else if (toScaleX != null) {				//trace ("  ~ rescale(X) pro objekt", mc.name);				if (toScaleX < mc.scaleX) {					makeSmaller (mc, toScaleX, fce, event, eventMC, speed, true, false);				} else {					makeLarger (mc, toScaleX, fce, event, eventMC, speed, true, false);				}			} else if (toScaleY != null) {				//trace ("  ~ rescale(Y) pro objekt", mc.name);				if (toScaleY < mc.scaleY) {					makeSmaller (mc, toScaleY, fce, event, eventMC, speed, false);				} else {					makeLarger (mc, toScaleY, fce, event, eventMC, speed, false);				}			}		}				/**		 * 		 * Změna velikosti absolutně		 * 		 * @param mc (*) je animovaný objekt		 * @param toScaleX (Number) maximální hodnota		 * @param toScaleY (Number) maximální hodnota		 * @param fce (Function) je funkce volaná po dokončení animace		 * @param event (String) je událost volaná po dokončení animace		 * @param eventMC (*) je objekt, na kterém se má volat událost		 * @param speed (Number) je konstanta do vzorce pro rychlost		 * 		 */		public static function resize (mc:*, toSizeX:* = null, toSizeY:* = null, speed:Number = 10, fce:Function = null, event:String = null, eventMC:* = null):void {						var toScaleX:* = null;			var toScaleY:* = null;			var originalX:Number = mc.width / mc.scaleX;			var originalY:Number = mc.height / mc.scaleY;						if (toSizeX == null) {				toScaleX = mc.scaleX;			} else {				toScaleX = toSizeX / originalX;			}						if (toSizeY == null) {				toScaleY = mc.scaleY;			} else {				toScaleY = toSizeY / originalY;			}						if (toScaleX != null && toScaleY != null) {				//trace ("  ~ rescale(X+Y) pro objekt", mc.name);								if (toScaleX == toScaleY) {					//trace ("  ~ rescale(X&Y) pro objekt", mc.name);					if (toScaleX < mc.scaleX) {						makeSmaller (mc, toScaleX, fce, event, eventMC, speed);					} else {						makeLarger (mc, toScaleX, fce, event, eventMC, speed);					}				} else {					//trace ("  ~ rescale(X,Y) pro objekt", mc.name);					if (toScaleX < mc.scaleX) {						makeSmaller (mc, toScaleX, fce, event, eventMC, speed, true, false);					} else {						makeLarger (mc, toScaleX, fce, event, eventMC, speed, true, false);					}					if (toScaleY < mc.scaleY) {						makeSmaller (mc, toScaleY, null, null, null, speed, false);					} else {						makeLarger (mc, toScaleY, null, null, null, speed, false);					}				}			} else if (toScaleX != null) {				trace ("  ~ rescale(X) pro objekt", mc.name);				if (toScaleX < mc.scaleX) {					makeSmaller (mc, toScaleX, fce, event, eventMC, speed, true, false);				} else {					makeLarger (mc, toScaleX, fce, event, eventMC, speed, true, false);				}			} else if (toScaleY != null) {				trace ("  ~ rescale(Y) pro objekt", mc.name);				if (toScaleY < mc.scaleY) {					makeSmaller (mc, toScaleY, fce, event, eventMC, speed, false);				} else {					makeLarger (mc, toScaleY, fce, event, eventMC, speed, false);				}			}		}	}}